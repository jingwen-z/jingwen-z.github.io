<!DOCTYPE html><html lang="en">
  <head><!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-85831520-1"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-85831520-1');
		
	</script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"><title>R IN ACTION Review 5 - Time series (Part 3) - Jingwen Zheng</title>

<meta name="description" content="In this blog, I’ll introduce ARIMA forecasting models. In the autoregressiveintegrated moving average (ARIMA) approach to forecasting, predicted values area ...">

<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>R IN ACTION Review 5 - Time series (Part 3) | Jingwen Zheng</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="R IN ACTION Review 5 - Time series (Part 3)" />
<meta name="author" content="Jingwen Zheng" />
<meta property="og:locale" content="en" />
<meta name="description" content="In this blog, I’ll introduce ARIMA forecasting models. In the autoregressive integrated moving average (ARIMA) approach to forecasting, predicted values are a linear function of recent actual values and recent errors of prediction (residuals). Before describing ARIMA models, we need to define a number of terms: lags, autocorrelation, partial autocorrelation, stationarity and differencing[1]. Prerequisite concepts When you lag a time series, you shift it back by a given number of observations. Autocorrelation measures the way observations in a time series relate to each other. is the correlation between a set of observations () and observationsk periods earlier (). So is the correlation between the Lag 1 and Lag 0 time series, is the correlation between the Lag 2 and Lag 0 time series, and so on. Plotting these correlations produices an autocorrelation function (ACF) plot. The ACF plot is used to select appropriate parameters for the ARIMA model and to assess the fit of the final model. An ACF plot can be produced with the acf() function in the stats package or the Acf() function in the forecast package. Here, Acf() function is used because it produces a plot that is somewhat easier to read. A partial autocorrelation is the correlation between and with the effects of all Y values between the two removed. Partial autocorrelations can also be plotted for multiple values of k. The PACF plot can be generated with either the pacf() function in the stats package or the Pacf() function in the forecast package. The PACF plot is also used to determine the most appropriate parameters for the ARIMA model. ARIMA models are designed to fit stationary time series. In a stationary time series, the statistical properties of the series don’t change over time. Because stationary time series are assumed to have constant means, they can’t have a trend component. Many non-stationary time series can be made stationary through differencing. In differencing, each value of a time series is replace with . Differencing a time series once removes a linear trend. Differencing it a second time removes a quadratic trend. A third time removes a cubic trend. It’s rarely necessary to difference more than twice. Stationarity is often evaluated with a visuel inspection of a time-series plot. If the variance isn’t constant, the data are transformed. If there are trends, the data are difference. You can also use a statistical procedure called the Augmented Dickey-Fuller (ADF) test to evaluate the assumption of stationarity. With these concepts in hand, we can turn to fitting models with an autoregressive (AR) component, a moving averages (MA) component, or both components (ARMA). Finally, we’ll examine ARIMA models that include ARMA components and differencing to achieve stationarity. ARMA and ARIMA models In an autoregressive model of order p, each value in a time series is predicted from a linear combinatioin of the previous p values where is a given value of the series, µ is the mean of the series, the are the weights, and is the irregular component. In a moving average model of order q, each value in the time series is predicted from a linear combination of q previous errors. In this case where the are the errors of prediction and the are the weights. Combining the two approaches yields an ARMA(p, q) model of the form that predicts each value of the time series from the past p values and q residuals. An ARIMA(p, d, q) model is a model in which the time series has been differenced d times, and the resulting values are predicted from the previous p actual values and q previous errors. The predictions are “un-differenced” or integrated to achieve the final prediction. Let’s apply each step in turn to fit an ARIMA model to the Nile time series. Ensuring that the time series is stationary First we plot the time series and assess its stationarity. The variance appears to be stable across the years observed, so there’s no need for a transformation. There may be a trend, which is supported by the results of the ndiffs() function. dNile &lt;- diff(Nile) plot(dNile) adf.test(dNile) The differenced time series is plotted as following and certainly looks more stationary. Applying the ADF test to the differenced series suggest that it’s now stationary, so we can proceed to the next step. Identifying one or more reasonable models Possible models are selected based on the ACF and PACF plots: For the figure above, there appears to be one large autocorrelation at lag 1, and the partial autocorrelation trail off to zero as the lags get bigger. This suggests trying an ARIMA(0, 1, 1) model. Fitting the model(s) fit &lt;- arima(Nile, order = c(0, 1, 1)) fit # Call: # arima(x = Nile, order = c(0, 1, 1)) # Coefficients: # ma1 # -0.7329 # s.e. 0.1143 # sigma^2 estimated as 20600: log likelihood = -632.55, aic = 1269.09 accuracy(fit) The coefficient for the moving averages (-0.73) is provided along with the AIC. If you fit other models, the AIC can help you choose which one is most reasonable. Smaller AIC values suggest better models. The accuracy measures can help you determine whether the model fits with sufficient accuracy. Evaluating model fit If the model is appropriate, the residuals should be normally distributed with mean zero, and the autocorrelations should be zero for every possible lag. qqnorm(fit$residuals) qqline(fit$residuals) Box.test(fit$residuals, type = &quot;Ljung-Box&quot;) Normally distributed data should fall along the line. In this case, the results look good. The Box.test() function provides a test that the autocorrelations are all zero. The results suggest that the autocorrelations don’t differ from zero. This ARIMA model appears to fit the data well. Making forecasts Once a final model has been chosen, it can be used to make predictions of future values. Point estimates are given by the blue dots, and 80% and 95% confidence bands are represented by dark and light bands, respectively. In the last 3 blogs, we’ve looked at how to create time series in R, assess trends, and examine seasonal effects. Then we considered two of the most popular approaches to forecasting: exponential models and ARIMA models. Although these methodologies can be crucial in understanding and predicting a wide variety of phenomena, it’s important to remember that they each entail extrapolation - going beyond the data. Reference [1] Robert I. Kabacoff. 2015. “Chapter 15 Time series” R IN ACTION Data analysis and graphics with R p 359-366 Pexels, “night stars rotation starry sky”, pixabay.com. [Online]. Available: https://pixabay.com/photos/night-stars-rotation-starry-sky-1846734/" />
<meta property="og:description" content="In this blog, I’ll introduce ARIMA forecasting models. In the autoregressive integrated moving average (ARIMA) approach to forecasting, predicted values are a linear function of recent actual values and recent errors of prediction (residuals). Before describing ARIMA models, we need to define a number of terms: lags, autocorrelation, partial autocorrelation, stationarity and differencing[1]. Prerequisite concepts When you lag a time series, you shift it back by a given number of observations. Autocorrelation measures the way observations in a time series relate to each other. is the correlation between a set of observations () and observationsk periods earlier (). So is the correlation between the Lag 1 and Lag 0 time series, is the correlation between the Lag 2 and Lag 0 time series, and so on. Plotting these correlations produices an autocorrelation function (ACF) plot. The ACF plot is used to select appropriate parameters for the ARIMA model and to assess the fit of the final model. An ACF plot can be produced with the acf() function in the stats package or the Acf() function in the forecast package. Here, Acf() function is used because it produces a plot that is somewhat easier to read. A partial autocorrelation is the correlation between and with the effects of all Y values between the two removed. Partial autocorrelations can also be plotted for multiple values of k. The PACF plot can be generated with either the pacf() function in the stats package or the Pacf() function in the forecast package. The PACF plot is also used to determine the most appropriate parameters for the ARIMA model. ARIMA models are designed to fit stationary time series. In a stationary time series, the statistical properties of the series don’t change over time. Because stationary time series are assumed to have constant means, they can’t have a trend component. Many non-stationary time series can be made stationary through differencing. In differencing, each value of a time series is replace with . Differencing a time series once removes a linear trend. Differencing it a second time removes a quadratic trend. A third time removes a cubic trend. It’s rarely necessary to difference more than twice. Stationarity is often evaluated with a visuel inspection of a time-series plot. If the variance isn’t constant, the data are transformed. If there are trends, the data are difference. You can also use a statistical procedure called the Augmented Dickey-Fuller (ADF) test to evaluate the assumption of stationarity. With these concepts in hand, we can turn to fitting models with an autoregressive (AR) component, a moving averages (MA) component, or both components (ARMA). Finally, we’ll examine ARIMA models that include ARMA components and differencing to achieve stationarity. ARMA and ARIMA models In an autoregressive model of order p, each value in a time series is predicted from a linear combinatioin of the previous p values where is a given value of the series, µ is the mean of the series, the are the weights, and is the irregular component. In a moving average model of order q, each value in the time series is predicted from a linear combination of q previous errors. In this case where the are the errors of prediction and the are the weights. Combining the two approaches yields an ARMA(p, q) model of the form that predicts each value of the time series from the past p values and q residuals. An ARIMA(p, d, q) model is a model in which the time series has been differenced d times, and the resulting values are predicted from the previous p actual values and q previous errors. The predictions are “un-differenced” or integrated to achieve the final prediction. Let’s apply each step in turn to fit an ARIMA model to the Nile time series. Ensuring that the time series is stationary First we plot the time series and assess its stationarity. The variance appears to be stable across the years observed, so there’s no need for a transformation. There may be a trend, which is supported by the results of the ndiffs() function. dNile &lt;- diff(Nile) plot(dNile) adf.test(dNile) The differenced time series is plotted as following and certainly looks more stationary. Applying the ADF test to the differenced series suggest that it’s now stationary, so we can proceed to the next step. Identifying one or more reasonable models Possible models are selected based on the ACF and PACF plots: For the figure above, there appears to be one large autocorrelation at lag 1, and the partial autocorrelation trail off to zero as the lags get bigger. This suggests trying an ARIMA(0, 1, 1) model. Fitting the model(s) fit &lt;- arima(Nile, order = c(0, 1, 1)) fit # Call: # arima(x = Nile, order = c(0, 1, 1)) # Coefficients: # ma1 # -0.7329 # s.e. 0.1143 # sigma^2 estimated as 20600: log likelihood = -632.55, aic = 1269.09 accuracy(fit) The coefficient for the moving averages (-0.73) is provided along with the AIC. If you fit other models, the AIC can help you choose which one is most reasonable. Smaller AIC values suggest better models. The accuracy measures can help you determine whether the model fits with sufficient accuracy. Evaluating model fit If the model is appropriate, the residuals should be normally distributed with mean zero, and the autocorrelations should be zero for every possible lag. qqnorm(fit$residuals) qqline(fit$residuals) Box.test(fit$residuals, type = &quot;Ljung-Box&quot;) Normally distributed data should fall along the line. In this case, the results look good. The Box.test() function provides a test that the autocorrelations are all zero. The results suggest that the autocorrelations don’t differ from zero. This ARIMA model appears to fit the data well. Making forecasts Once a final model has been chosen, it can be used to make predictions of future values. Point estimates are given by the blue dots, and 80% and 95% confidence bands are represented by dark and light bands, respectively. In the last 3 blogs, we’ve looked at how to create time series in R, assess trends, and examine seasonal effects. Then we considered two of the most popular approaches to forecasting: exponential models and ARIMA models. Although these methodologies can be crucial in understanding and predicting a wide variety of phenomena, it’s important to remember that they each entail extrapolation - going beyond the data. Reference [1] Robert I. Kabacoff. 2015. “Chapter 15 Time series” R IN ACTION Data analysis and graphics with R p 359-366 Pexels, “night stars rotation starry sky”, pixabay.com. [Online]. Available: https://pixabay.com/photos/night-stars-rotation-starry-sky-1846734/" />
<link rel="canonical" href="https://jingwen-z.github.io//r-in-action-review-5-time-series-(part-3)/" />
<meta property="og:url" content="https://jingwen-z.github.io//r-in-action-review-5-time-series-(part-3)/" />
<meta property="og:site_name" content="Jingwen Zheng" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-09-27T22:15:39+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="R IN ACTION Review 5 - Time series (Part 3)" />
<meta name="twitter:site" content="@Jingwen_QI" />
<meta name="twitter:creator" content="@Jingwen Zheng" />
<script type="application/ld+json">
{"description":"In this blog, I’ll introduce ARIMA forecasting models. In the autoregressive integrated moving average (ARIMA) approach to forecasting, predicted values are a linear function of recent actual values and recent errors of prediction (residuals). Before describing ARIMA models, we need to define a number of terms: lags, autocorrelation, partial autocorrelation, stationarity and differencing[1]. Prerequisite concepts When you lag a time series, you shift it back by a given number of observations. Autocorrelation measures the way observations in a time series relate to each other. is the correlation between a set of observations () and observationsk periods earlier (). So is the correlation between the Lag 1 and Lag 0 time series, is the correlation between the Lag 2 and Lag 0 time series, and so on. Plotting these correlations produices an autocorrelation function (ACF) plot. The ACF plot is used to select appropriate parameters for the ARIMA model and to assess the fit of the final model. An ACF plot can be produced with the acf() function in the stats package or the Acf() function in the forecast package. Here, Acf() function is used because it produces a plot that is somewhat easier to read. A partial autocorrelation is the correlation between and with the effects of all Y values between the two removed. Partial autocorrelations can also be plotted for multiple values of k. The PACF plot can be generated with either the pacf() function in the stats package or the Pacf() function in the forecast package. The PACF plot is also used to determine the most appropriate parameters for the ARIMA model. ARIMA models are designed to fit stationary time series. In a stationary time series, the statistical properties of the series don’t change over time. Because stationary time series are assumed to have constant means, they can’t have a trend component. Many non-stationary time series can be made stationary through differencing. In differencing, each value of a time series is replace with . Differencing a time series once removes a linear trend. Differencing it a second time removes a quadratic trend. A third time removes a cubic trend. It’s rarely necessary to difference more than twice. Stationarity is often evaluated with a visuel inspection of a time-series plot. If the variance isn’t constant, the data are transformed. If there are trends, the data are difference. You can also use a statistical procedure called the Augmented Dickey-Fuller (ADF) test to evaluate the assumption of stationarity. With these concepts in hand, we can turn to fitting models with an autoregressive (AR) component, a moving averages (MA) component, or both components (ARMA). Finally, we’ll examine ARIMA models that include ARMA components and differencing to achieve stationarity. ARMA and ARIMA models In an autoregressive model of order p, each value in a time series is predicted from a linear combinatioin of the previous p values where is a given value of the series, µ is the mean of the series, the are the weights, and is the irregular component. In a moving average model of order q, each value in the time series is predicted from a linear combination of q previous errors. In this case where the are the errors of prediction and the are the weights. Combining the two approaches yields an ARMA(p, q) model of the form that predicts each value of the time series from the past p values and q residuals. An ARIMA(p, d, q) model is a model in which the time series has been differenced d times, and the resulting values are predicted from the previous p actual values and q previous errors. The predictions are “un-differenced” or integrated to achieve the final prediction. Let’s apply each step in turn to fit an ARIMA model to the Nile time series. Ensuring that the time series is stationary First we plot the time series and assess its stationarity. The variance appears to be stable across the years observed, so there’s no need for a transformation. There may be a trend, which is supported by the results of the ndiffs() function. dNile &lt;- diff(Nile) plot(dNile) adf.test(dNile) The differenced time series is plotted as following and certainly looks more stationary. Applying the ADF test to the differenced series suggest that it’s now stationary, so we can proceed to the next step. Identifying one or more reasonable models Possible models are selected based on the ACF and PACF plots: For the figure above, there appears to be one large autocorrelation at lag 1, and the partial autocorrelation trail off to zero as the lags get bigger. This suggests trying an ARIMA(0, 1, 1) model. Fitting the model(s) fit &lt;- arima(Nile, order = c(0, 1, 1)) fit # Call: # arima(x = Nile, order = c(0, 1, 1)) # Coefficients: # ma1 # -0.7329 # s.e. 0.1143 # sigma^2 estimated as 20600: log likelihood = -632.55, aic = 1269.09 accuracy(fit) The coefficient for the moving averages (-0.73) is provided along with the AIC. If you fit other models, the AIC can help you choose which one is most reasonable. Smaller AIC values suggest better models. The accuracy measures can help you determine whether the model fits with sufficient accuracy. Evaluating model fit If the model is appropriate, the residuals should be normally distributed with mean zero, and the autocorrelations should be zero for every possible lag. qqnorm(fit$residuals) qqline(fit$residuals) Box.test(fit$residuals, type = &quot;Ljung-Box&quot;) Normally distributed data should fall along the line. In this case, the results look good. The Box.test() function provides a test that the autocorrelations are all zero. The results suggest that the autocorrelations don’t differ from zero. This ARIMA model appears to fit the data well. Making forecasts Once a final model has been chosen, it can be used to make predictions of future values. Point estimates are given by the blue dots, and 80% and 95% confidence bands are represented by dark and light bands, respectively. In the last 3 blogs, we’ve looked at how to create time series in R, assess trends, and examine seasonal effects. Then we considered two of the most popular approaches to forecasting: exponential models and ARIMA models. Although these methodologies can be crucial in understanding and predicting a wide variety of phenomena, it’s important to remember that they each entail extrapolation - going beyond the data. Reference [1] Robert I. Kabacoff. 2015. “Chapter 15 Time series” R IN ACTION Data analysis and graphics with R p 359-366 Pexels, “night stars rotation starry sky”, pixabay.com. [Online]. Available: https://pixabay.com/photos/night-stars-rotation-starry-sky-1846734/","mainEntityOfPage":{"@type":"WebPage","@id":"https://jingwen-z.github.io//r-in-action-review-5-time-series-(part-3)/"},"@type":"BlogPosting","url":"https://jingwen-z.github.io//r-in-action-review-5-time-series-(part-3)/","headline":"R IN ACTION Review 5 - Time series (Part 3)","dateModified":"2017-09-27T22:15:39+02:00","datePublished":"2017-09-27T22:15:39+02:00","author":{"@type":"Person","name":"Jingwen Zheng"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


<!-- Extra Open Graph :: Start -->

<!-- Extra Open Graph :: End -->

<link rel="canonical" href="https://jingwen-z.github.io//r-in-action-review-5-time-series-(part-3)/"><link rel="alternate" type="application/rss+xml" title="Jingwen Zheng" href="/feed.xml"><!-- start favicons snippet, use https://realfavicongenerator.net/ --><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png"><link rel="manifest" href="/assets/site.webmanifest"><link rel="mask-icon" href="/assets/safari-pinned-tab.svg" color="#fc4d50"><link rel="shortcut icon" href="/assets/favicon.ico">

<meta name="msapplication-TileColor" content="#ffc40d"><meta name="msapplication-config" content="/assets/browserconfig.xml">

<meta name="theme-color" content="#ffffff">
<!-- end favicons snippet --><link rel="stylesheet" href="/assets/css/main.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.1/css/all.css" ><!-- start custom head snippets -->

<!-- end custom head snippets -->
<script>(function() {
  window.isArray = function(val) {
    return Object.prototype.toString.call(val) === '[object Array]';
  };
  window.isString = function(val) {
    return typeof val === 'string';
  };

  window.hasEvent = function(event) {
    return 'on'.concat(event) in window.document;
  };

  window.isOverallScroller = function(node) {
    return node === document.documentElement || node === document.body || node === window;
  };

  window.isFormElement = function(node) {
    var tagName = node.tagName;
    return tagName === 'INPUT' || tagName === 'SELECT' || tagName === 'TEXTAREA';
  };

  window.pageLoad = (function () {
    var loaded = false, cbs = [];
    window.addEventListener('load', function () {
      var i;
      loaded = true;
      if (cbs.length > 0) {
        for (i = 0; i < cbs.length; i++) {
          cbs[i]();
        }
      }
    });
    return {
      then: function(cb) {
        cb && (loaded ? cb() : (cbs.push(cb)));
      }
    };
  })();
})();
(function() {
  window.throttle = function(func, wait) {
    var args, result, thisArg, timeoutId, lastCalled = 0;

    function trailingCall() {
      lastCalled = new Date;
      timeoutId = null;
      result = func.apply(thisArg, args);
    }
    return function() {
      var now = new Date,
        remaining = wait - (now - lastCalled);

      args = arguments;
      thisArg = this;

      if (remaining <= 0) {
        clearTimeout(timeoutId);
        timeoutId = null;
        lastCalled = now;
        result = func.apply(thisArg, args);
      } else if (!timeoutId) {
        timeoutId = setTimeout(trailingCall, remaining);
      }
      return result;
    };
  };
})();
(function() {
  var Set = (function() {
    var add = function(item) {
      var i, data = this._data;
      for (i = 0; i < data.length; i++) {
        if (data[i] === item) {
          return;
        }
      }
      this.size ++;
      data.push(item);
      return data;
    };

    var Set = function(data) {
      this.size = 0;
      this._data = [];
      var i;
      if (data.length > 0) {
        for (i = 0; i < data.length; i++) {
          add.call(this, data[i]);
        }
      }
    };
    Set.prototype.add = add;
    Set.prototype.get = function(index) { return this._data[index]; };
    Set.prototype.has = function(item) {
      var i, data = this._data;
      for (i = 0; i < data.length; i++) {
        if (this.get(i) === item) {
          return true;
        }
      }
      return false;
    };
    Set.prototype.is = function(map) {
      if (map._data.length !== this._data.length) { return false; }
      var i, j, flag, tData = this._data, mData = map._data;
      for (i = 0; i < tData.length; i++) {
        for (flag = false, j = 0; j < mData.length; j++) {
          if (tData[i] === mData[j]) {
            flag = true;
            break;
          }
        }
        if (!flag) { return false; }
      }
      return true;
    };
    Set.prototype.values = function() {
      return this._data;
    };
    return Set;
  })();

  window.Lazyload = (function(doc) {
    var queue = {js: [], css: []}, sources = {js: {}, css: {}}, context = this;
    var createNode = function(name, attrs) {
      var node = doc.createElement(name), attr;
      for (attr in attrs) {
        if (attrs.hasOwnProperty(attr)) {
          node.setAttribute(attr, attrs[attr]);
        }
      }
      return node;
    };
    var end = function(type, url) {
      var s, q, qi, cbs, i, j, cur, val, flag;
      if (type === 'js' || type ==='css') {
        s = sources[type], q = queue[type];
        s[url] = true;
        for (i = 0; i < q.length; i++) {
          cur = q[i];
          if (cur.urls.has(url)) {
            qi = cur, val = qi.urls.values();
            qi && (cbs = qi.callbacks);
            for (flag = true, j = 0; j < val.length; j++) {
              cur = val[j];
              if (!s[cur]) {
                flag = false;
              }
            }
            if (flag && cbs && cbs.length > 0) {
              for (j = 0; j < cbs.length; j++) {
                cbs[j].call(context);
              }
              qi.load = true;
            }
          }
        }
      }
    };
    var load = function(type, urls, callback) {
      var s, q, qi, node, i, cur,
        _urls = typeof urls === 'string' ? new Set([urls]) : new Set(urls), val, url;
      if (type === 'js' || type ==='css') {
        s = sources[type], q = queue[type];
        for (i = 0; i < q.length; i++) {
          cur = q[i];
          if (_urls.is(cur.urls)) {
            qi = cur;
            break;
          }
        }
        val = _urls.values();
        if (qi) {
          callback && (qi.load || qi.callbacks.push(callback));
          callback && (qi.load && callback());
        } else {
          q.push({
            urls: _urls,
            callbacks: callback ? [callback] : [],
            load: false
          });
          for (i = 0; i < val.length; i++) {
            node = null, url = val[i];
            if (s[url] === undefined) {
              (type === 'js' ) && (node = createNode('script', { src: url }));
              (type === 'css') && (node = createNode('link', { rel: 'stylesheet', href: url }));
              if (node) {
                node.onload = (function(type, url) {
                  return function() {
                    end(type, url);
                  };
                })(type, url);
                (doc.head || doc.body).appendChild(node);
                s[url] = false;
              }
            }
          }
        }
      }
    };
    return {
      js: function(url, callback) {
        load('js', url, callback);
      },
      css: function(url, callback) {
        load('css', url, callback);
      }
    };
  })(this.document);
})();
</script><script>
  (function() {
    var TEXT_VARIABLES = {
      version: '2.2.6',
      sources: {
        font_awesome: 'https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.1/css/all.css',
        jquery: 'https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js',
        leancloud_js_sdk: '//cdn.jsdelivr.net/npm/leancloud-storage@3.13.2/dist/av-min.js',
        chart: 'https://cdn.bootcss.com/Chart.js/2.7.2/Chart.bundle.min.js',
        gitalk: {
          js: 'https://cdn.bootcss.com/gitalk/1.2.2/gitalk.min.js',
          css: 'https://cdn.bootcss.com/gitalk/1.2.2/gitalk.min.css'
        },
        valine: 'https://unpkg.com/valine/dist/Valine.min.js',
        mathjax: 'https://cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML',
        mermaid: 'https://cdn.bootcss.com/mermaid/8.0.0-rc.8/mermaid.min.js'
      },
      site: {
        toc: {
          selectors: 'h1,h2,h3'
        }
      },
      paths: {
        search_js: '/assets/search.js'
      }
    };
    window.TEXT_VARIABLES = TEXT_VARIABLES;
  })();
</script>
</head>
  <body>
    <div class="root" data-is-touch="false">
      <div class="layout--page js-page-root"><div class="page__main js-page-main page__viewport has-aside cell cell--auto">

      <div class="page__main-inner"><div class="page__header d-print-none"><header class="header"><div class="main">
      <div class="header__title">
        <div class="header__brand"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="24px" height="24px" viewBox="0 0 24 24">
<style type="text/css">
	.st0{fill:#515151;}
</style>
<path class="st0" d="M1.7,22.3c5.7-5.7,11.3-5.7,17,0c3.3-3.3,3.5-5.3,0.8-6c2.7,0.7,3.5-1.1,2.3-5.6s-3.3-5.2-6.3-2.1
	c3-3,2.3-5.2-2.1-6.3S7,1.8,7.7,4.6C7,1.8,5,2.1,1.7,5.3C7.3,11,7.3,16.7,1.7,22.3"/>
</svg>

          <a title="Data Science Enthusiast
" href="/">Jingwen Zheng</a>
        </div><button class="button button--secondary button--circle search-button js-search-toggle"><i class="fas fa-search"></i></button></div><nav class="navigation">
        <ul><li class="navigation__item"><a href="/portfolio">Portfolio</a></li><li class="navigation__item"><a href="/archive">Archive</a></li><li class="navigation__item"><a href="/about">About</a></li><li><button class="button button--secondary button--circle search-button js-search-toggle"><i class="fas fa-search"></i></button></li></ul>
      </nav></div>
  </header>
</div><div class="page__content"><div class="article__header--overlay"><div class="hero hero--dark overlay" style="background-image:linear-gradient(135deg, rgba(0, 0, 0, .6), rgba(0, 0, 0, .4)),url(/images/20170729-night.jpg);background-color:#203028;"><div class="hero__content"><div class ="main"><div class="article__info clearfix">
      <ul class="left-col menu">
        <li>
              <a class="button button--secondary button--pill button--sm"
                href="/archive?tag=R">R</a>
            </li><li>
              <a class="button button--secondary button--pill button--sm"
                href="/archive?tag=Machine-Learning">Machine-Learning</a>
            </li><li>
              <a class="button button--secondary button--pill button--sm"
                href="/archive?tag=Time-series">Time-series</a>
            </li>

      <li class="separator">|</li>
        
          <li>
            <a class="button button--circle button--primary focus lang"
               href="/r-in-action-review-5-time-series-(part-3)/"><span>EN</span></a>

            






            

            
          </li>
        
      
    </ul><ul class="right-col menu"><li><i class="far fa-calendar-alt"></i> <span>Sep 27, 2017</span>
            </li></ul></div><div class="article__header"><header><h1>R IN ACTION Review 5 - Time series (Part 3)</h1></header></div><p class="overlay__excerpt">In this blog, I’ll introduce ARIMA forecasting models. In the autoregressiveintegrated moving average (ARIMA) approach to forecasting, predicted values area linear function of recent actual values ...</p></div></div>
              </div>
            </div><div class ="main"><div class="grid grid--reverse">

              <div class="col-aside d-print-none js-col-aside"><aside class="page__aside js-page-aside"><div class="toc-aside js-toc-root"></div>
</aside></div>

              <div class="col-main cell cell--auto"><!-- start custom main top snippet -->

<!-- end custom main top snippet -->
<article itemscope itemtype="http://schema.org/Article"><meta itemprop="headline" content="R IN ACTION Review 5 - Time series (Part 3)"><meta itemprop="author" content="Jingwen Zheng"/><meta itemprop="datePublished" content="2017-09-27T22:15:39+02:00">
    <meta itemprop="keywords" content="R,Machine-Learning,Time-series"><div class="js-article-content"><div class="layout--article"><!-- start custom article top snippet -->

<!-- end custom article top snippet -->
<div class="article__content" itemprop="articleBody"><p>In this blog, I’ll introduce ARIMA forecasting models. In the <em>autoregressive
integrated moving average (ARIMA)</em> approach to forecasting, predicted values are
a linear function of recent actual values and recent errors of prediction
(residuals). Before describing ARIMA models, we need to define a number of terms:
lags, autocorrelation, partial autocorrelation, stationarity and differencing[1].</p>

<h2 id="prerequisite-concepts">Prerequisite concepts</h2>

<p>When you <em>lag</em> a time series, you shift it back by a given number of
observations. <em>Autocorrelation</em> measures the way observations in a time series
relate to each other. <img alt="AC_k" src="https://latex.codecogs.com/gif.latex?\fn_jvn&space;AC_{k}" />
is the correlation between a set of observations
(<img alt="Y_t" src="https://latex.codecogs.com/gif.latex?\fn_jvn&space;Y_{t}" />) and
observationsk periods earlier
(<img alt="Y_t-k" src="https://latex.codecogs.com/gif.latex?\fn_jvn&space;Y_{t-k}" />).
So <img alt="AC_1" src="https://latex.codecogs.com/gif.latex?\fn_jvn&space;AC_{1}" />
is the correlation between the Lag 1 and Lag 0 time series,
<img alt="AC_2" src="https://latex.codecogs.com/gif.latex?\fn_jvn&space;AC_{2}" /> is the
correlation between the Lag 2 and Lag 0 time series, and so on. Plotting these
correlations produices an <em>autocorrelation function (ACF) plot</em>. The ACF plot is
used to select appropriate parameters for the ARIMA model and to assess the fit
of the final model. An ACF plot can be produced with the <code class="language-plaintext highlighter-rouge">acf()</code> function in the
<code class="language-plaintext highlighter-rouge">stats</code> package or the <code class="language-plaintext highlighter-rouge">Acf()</code> function in the <code class="language-plaintext highlighter-rouge">forecast</code> package. Here, <code class="language-plaintext highlighter-rouge">Acf()</code>
function is used because it produces a plot that is somewhat easier to read.</p>

<p>A <em>partial autocorrelation</em> is the correlation between
<img alt="Y_t" src="https://latex.codecogs.com/gif.latex?\fn_jvn&space;Y_{t}" />
and <img alt="Y_t-k" src="https://latex.codecogs.com/gif.latex?\fn_jvn&space;Y_{t-k}" />
with the effects of all Y values between the two removed. Partial
autocorrelations can also be plotted for multiple values of <em>k</em>. The PACF plot
can be generated with either the <code class="language-plaintext highlighter-rouge">pacf()</code> function in the <code class="language-plaintext highlighter-rouge">stats</code> package or the
<code class="language-plaintext highlighter-rouge">Pacf()</code> function in the <code class="language-plaintext highlighter-rouge">forecast</code> package. The PACF plot is also used to
determine the most appropriate parameters for the ARIMA model.</p>

<p>ARIMA models are designed to fit <em>stationary</em> time series. In a stationary time
series, the statistical properties of the series don’t change over time. Because
stationary time series are assumed to have constant means, they can’t have a
trend component. Many non-stationary time series can be made stationary through
<em>differencing</em>. In differencing, each value of a time series
<img alt="Y_t" src="https://latex.codecogs.com/gif.latex?\fn_jvn&space;Y_{t}" />
is replace with
<img alt="Y_t-1-Y_t" src="https://latex.codecogs.com/gif.latex?\fn_jvn&space;Y_{t-1}-Y_{t}" />.
Differencing a time series once removes a linear trend. Differencing it a second
time removes a quadratic trend. A third time removes a cubic trend. It’s rarely
necessary to difference more than twice.</p>

<p>Stationarity is often evaluated with a visuel inspection of a time-series plot.
If the variance isn’t constant, the data are transformed. If there are trends,
the data are difference. You can also use a statistical procedure called the
<em>Augmented Dickey-Fuller (ADF) test</em> to evaluate the assumption of stationarity.</p>

<p>With these concepts in hand, we can turn to fitting models with an
autoregressive (AR) component, a moving averages (MA) component, or both
components (ARMA). Finally, we’ll examine ARIMA models that include ARMA
components and differencing to achieve stationarity.</p>

<h2 id="arma-and-arima-models">ARMA and ARIMA models</h2>

<p>In an <em>autoregressive</em> model of order <em>p</em>, each value in a time series is
predicted from a linear combinatioin of the previous p values</p>

<p align="center">
<img alt="AR" src="https://latex.codecogs.com/gif.latex?\fn_jvn&space;AR(p):&space;Y_{t}&space;=&space;\mu&space;&plus;&space;\beta&space;_{1}Y_{t-1}&space;&plus;&space;\beta&space;_{2}Y_{t-2}&space;&plus;&space;...&space;&plus;&space;\beta&space;_{p}Y_{t-p}&space;&plus;\epsilon&space;_{t}" />
</p>

<p>where <img alt="Y_t" src="https://latex.codecogs.com/gif.latex?\fn_jvn&space;Y_{t}" />
is a given value of the series, <em>µ</em> is the mean of the series, the
<img alt="betas" src="https://latex.codecogs.com/gif.latex?\fn_jvn&space;\beta&space;_{s}" />
are the weights, and <img alt="epsilon" src="https://latex.codecogs.com/gif.latex?\fn_jvn&space;\epsilon&space;_{s}" />
is the irregular component.</p>

<p>In a <em>moving average</em> model of order <em>q</em>, each value in the time series is
predicted from a linear combination of q previous errors. In this case</p>

<p align="center">
<img alt="MA" src="https://latex.codecogs.com/gif.latex?\fn_jvn&space;MA(q):&space;Y_{t}&space;=&space;\mu&space;-&space;\theta&space;_{1}\epsilon&space;_{t-1}&space;-&space;\theta&space;_{2}\epsilon&space;_{t-2}&space;...&space;-&space;\theta&space;_{q}\epsilon&space;_{t-q}&space;&plus;&space;\epsilon&space;_{t}" />
</p>

<p>where the <img alt="epsilons" src="https://latex.codecogs.com/gif.latex?\fn_jvn&space;\epsilon&space;_{s}" />
are the errors of prediction and the <img alt="thetas" src="https://latex.codecogs.com/gif.latex?\fn_jvn&space;\theta&space;_{s}" />
are the weights.</p>

<p>Combining the two approaches yields an ARMA(p, q) model of the form</p>

<p align="center">
<img alt="ARMA model" src="https://latex.codecogs.com/gif.latex?\fn_jvn&space;Y_{t}&space;=&space;\mu&space;&plus;&space;\beta&space;_{1}Y_{t-1}&space;&plus;&space;\beta&space;_{2}Y_{t-2}&space;&plus;&space;...&space;&plus;&space;\beta&space;_{p}Y_{t-p}&space;-&space;\theta&space;_{1}\epsilon&space;_{t-1}&space;-&space;\theta&space;_{2}\epsilon&space;_{t-2}&space;-&space;...&space;-&space;\theta&space;_{q}\epsilon&space;_{t-q}&space;&plus;&space;\epsilon&space;_{t}" />
</p>

<p>that predicts each value of the time series from the past <em>p</em> values and <em>q</em>
residuals.</p>

<p>An ARIMA(p, d, q) model is a model in which the time series has been differenced
<em>d</em> times, and the resulting values are predicted from the previous <em>p</em> actual
values and <em>q</em> previous errors. The predictions are “un-differenced” or
<em>integrated</em> to achieve the final prediction.</p>

<p>Let’s apply each step in turn to fit an ARIMA model to the <code class="language-plaintext highlighter-rouge">Nile</code> time series.</p>

<h3 id="ensuring-that-the-time-series-is-stationary">Ensuring that the time series is stationary</h3>

<p>First we plot the time series and assess its stationarity.</p>

<p align="center">
  <img alt="Nile" src="/images/20170927-nile.png" />
</p>

<p>The variance appears to be stable across the years observed, so there’s no need
for a transformation. There may be a trend, which is supported by the results of
the <code class="language-plaintext highlighter-rouge">ndiffs()</code> function.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">dNile</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">diff</span><span class="p">(</span><span class="n">Nile</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">dNile</span><span class="p">)</span><span class="w">
</span><span class="n">adf.test</span><span class="p">(</span><span class="n">dNile</span><span class="p">)</span></code></pre></figure>

<p>The differenced time series is plotted as following and certainly looks more
stationary. Applying the ADF test to the differenced series suggest that it’s
now stationary, so we can proceed to the next step.</p>

<p align="center">
  <img alt="diff Nile" src="/images/20170927-diff-nile.png" />
</p>

<h3 id="identifying-one-or-more-reasonable-models">Identifying one or more reasonable models</h3>

<p>Possible models are selected based on the ACF and PACF plots:</p>

<p align="center">
  <img alt="ACF" src="/images/20170927-acf.png" />
  <img alt="PACF" src="/images/20170927-pacf.png" />
</p>

<p>For the figure above, there appears to be one large autocorrelation at lag 1,
and the partial autocorrelation trail off to zero as the lags get bigger. This
suggests trying an ARIMA(0, 1, 1) model.</p>

<h3 id="fitting-the-models">Fitting the model(s)</h3>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">fit</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">arima</span><span class="p">(</span><span class="n">Nile</span><span class="p">,</span><span class="w"> </span><span class="n">order</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">))</span><span class="w">
</span><span class="n">fit</span><span class="w">

</span><span class="c1"># Call:</span><span class="w">
</span><span class="c1">#   arima(x = Nile, order = c(0, 1, 1))</span><span class="w">
</span><span class="c1"># Coefficients:</span><span class="w">
</span><span class="c1">#   ma1</span><span class="w">
</span><span class="c1"># -0.7329</span><span class="w">
</span><span class="c1"># s.e.   0.1143</span><span class="w">
</span><span class="c1"># sigma^2 estimated as 20600:  log likelihood = -632.55,  aic = 1269.09</span><span class="w">

</span><span class="n">accuracy</span><span class="p">(</span><span class="n">fit</span><span class="p">)</span></code></pre></figure>

<p>The coefficient for the moving averages (-0.73) is provided along with the AIC.
If you fit other models, the AIC can help you choose which one is most
reasonable. <em>Smaller AIC values suggest better models.</em> The accuracy measures
can help you determine whether the model fits with sufficient accuracy.</p>

<h3 id="evaluating-model-fit">Evaluating model fit</h3>

<p>If the model is appropriate, the residuals should be normally distributed with
mean zero, and the autocorrelations should be zero for every possible lag.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">qqnorm</span><span class="p">(</span><span class="n">fit</span><span class="o">$</span><span class="n">residuals</span><span class="p">)</span><span class="w">
</span><span class="n">qqline</span><span class="p">(</span><span class="n">fit</span><span class="o">$</span><span class="n">residuals</span><span class="p">)</span><span class="w">
</span><span class="n">Box.test</span><span class="p">(</span><span class="n">fit</span><span class="o">$</span><span class="n">residuals</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Ljung-Box"</span><span class="p">)</span></code></pre></figure>

<p align="center">
  <img alt="qqplot" src="/images/20170927-qqplot.png" />
</p>

<p><em>Normally distributed data should fall along the line.</em> In this case, the
results look good.</p>

<p>The <code class="language-plaintext highlighter-rouge">Box.test()</code> function provides a test that the autocorrelations are all zero.
The results suggest that the autocorrelations don’t differ from zero. This ARIMA
model appears to fit the data well.</p>

<h3 id="making-forecasts">Making forecasts</h3>

<p>Once a final model has been chosen, it can be used to make predictions of future
values.</p>

<p align="center">
  <img alt="forecast" src="/images/20170927-forecast.png" />
</p>

<p>Point estimates are given by the blue dots, and 80% and 95% confidence bands are
represented by dark and light bands, respectively.</p>

<p>In the last 3 blogs, we’ve looked at how to create time series in R, assess
trends, and examine seasonal effects. Then we considered two of the most popular
approaches to forecasting: exponential models and ARIMA models. Although these
methodologies can be crucial in understanding and predicting a wide variety of
phenomena, it’s important to remember that they each entail extrapolation -
going beyond the data.</p>

<h2 id="reference">Reference</h2>

<p>[1] Robert I. Kabacoff. 2015. “Chapter 15 Time series” <em>R IN ACTION Data
analysis and graphics with R</em> p 359-366</p>
<ul>
  <li>Pexels, “night stars rotation starry sky”, <em>pixabay.com</em>. [Online]. Available: <a href="https://pixabay.com/photos/night-stars-rotation-starry-sky-1846734/">https://pixabay.com/photos/night-stars-rotation-starry-sky-1846734/</a></li>
</ul>

</div><section class="article__sharing d-print-none"></section><div class="d-print-none"><footer class="article__footer"><meta itemprop="dateModified" content="2017-09-27T22:15:39+02:00"><!-- start custom article footer snippet -->

<!-- end custom article footer snippet -->
<div class="article__subscribe"><div class="subscribe"><i class="fas fa-rss"></i> <a type="application/rss+xml" href="/feed.xml">Subscribe</a></div></div><div class="article__license"><div class="license">
    <p>This work is licensed under a <a itemprop="license" rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/">Attribution-NonCommercial 4.0 International</a> license.
      <a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/">
        <img alt="Attribution-NonCommercial 4.0 International" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" />
      </a>
    </p>
  </div></div></footer>
<div class="article__section-navigator clearfix"><div class="previous"><span>PREVIOUS</span><a href="/r-in-action-review-4-time-series-(part-2)/">R IN ACTION Review 4 - Time series (Part 2)</a></div><div class="next"><span>NEXT</span><a href="/france-is-ai/">france is AI</a></div></div></div>

</div>

<script>(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    $(function() {
      var $this ,$scroll;
      var $articleContent = $('.js-article-content');
      var hasSidebar = $('.js-page-root').hasClass('layout--page--sidebar');
      var scroll = hasSidebar ? '.js-page-main' : 'html, body';
      $scroll = $(scroll);

      $articleContent.find('.highlight').each(function() {
        $this = $(this);
        $this.attr('data-lang', $this.find('code').attr('data-lang'));
      });
      $articleContent.find('h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]').each(function() {
        $this = $(this);
        $this.append($('<a class="anchor d-print-none" aria-hidden="true"></a>').html('<i class="fas fa-anchor"></i>'));
      });
      $articleContent.on('click', '.anchor', function() {
        $scroll.scrollToAnchor('#' + $(this).parent().attr('id'), 400);
      });
    });
  });
})();
</script>
</div><section class="page__comments d-print-none"><div id="disqus_thread"></div>
  <script>
  /**
  *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
  *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
  var disqus_config = function () {
    this.page.url = 'https://jingwen-z.github.io//r-in-action-review-5-time-series-(part-3)/';
    this.page.identifier = '/r-in-action-review-5-time-series-(part-3)';
  };
  (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://jingwen-z.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></section></article><!-- start custom main bottom snippet -->

<!-- end custom main bottom snippet -->
</div>
            </div></div></div><div class="page__footer d-print-none">
<footer class="footer py-4 js-page-footer">
  <div class="main"><div itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jingwen Zheng"><meta itemprop="url" content="/"><meta itemprop="description" content="Data Science Enthusiast"><div class="footer__author-links"><div class="author-links">
  <ul class="menu menu--nowrap menu--inline"><li title="Follow me on Linkedin.">
        <a class="button button--circle linkedin-button" itemprop="sameAs" href="https://www.linkedin.com/in/jingwen-zheng" target="_blank">
          <div class="icon"><svg fill="#000000" width="24px" height="24px" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M260.096 155.648c0 27.307008-9.899008 50.516992-29.696 69.632-19.796992 19.115008-45.396992 28.672-76.8 28.672-30.036992 0-54.612992-9.556992-73.728-28.672-19.115008-19.115008-28.672-42.324992-28.672-69.632 0-28.672 9.556992-52.224 28.672-70.656 19.115008-18.432 44.372992-27.648 75.776-27.648 31.403008 0 56.32 9.216 74.752 27.648 18.432 18.432 28.331008 41.984 29.696 70.656 0 0 0 0 0 0m-202.752 808.96c0 0 0-632.832 0-632.832 0 0 196.608 0 196.608 0 0 0 0 632.832 0 632.832 0 0-196.608 0-196.608 0 0 0 0 0 0 0m313.344-430.08c0-58.708992-1.364992-126.292992-4.096-202.752 0 0 169.984 0 169.984 0 0 0 10.24 88.064 10.24 88.064 0 0 4.096 0 4.096 0 40.96-68.267008 105.812992-102.4 194.56-102.4 68.267008 0 123.220992 22.868992 164.864 68.608 41.643008 45.739008 62.464 113.664 62.464 203.776 0 0 0 374.784 0 374.784 0 0-196.608 0-196.608 0 0 0 0-350.208 0-350.208 0-91.476992-33.451008-137.216-100.352-137.216-47.787008 0-81.236992 24.576-100.352 73.728-4.096 8.192-6.144 24.576-6.144 49.152 0 0 0 364.544 0 364.544 0 0-198.656 0-198.656 0 0 0 0-430.08 0-430.08 0 0 0 0 0 0" />
</svg>
</div>
        </a>
      </li><li title="Follow me on Github.">
        <a class="button button--circle github-button" itemprop="sameAs" href="https://github.com/jingwen-z" target="_blank">
          <div class="icon"><svg fill="#000000" width="24px" height="24px" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path class="svgpath" data-index="path_0" fill="#272636" d="M0 525.2c0 223.6 143.3 413.7 343 483.5 26.9 6.8 22.8-12.4 22.8-25.4l0-88.7c-155.3 18.2-161.5-84.6-172-101.7-21.1-36-70.8-45.2-56-62.3 35.4-18.2 71.4 4.6 113.1 66.3 30.2 44.7 89.1 37.2 119 29.7 6.5-26.9 20.5-50.9 39.7-69.6C248.8 728.2 181.7 630 181.7 513.2c0-56.6 18.7-108.7 55.3-150.7-23.3-69.3 2.2-128.5 5.6-137.3 66.5-6 135.5 47.6 140.9 51.8 37.8-10.2 80.9-15.6 129.1-15.6 48.5 0 91.8 5.6 129.8 15.9 12.9-9.8 77-55.8 138.8-50.2 3.3 8.8 28.2 66.7 6.3 135 37.1 42.1 56 94.6 56 151.4 0 117-67.5 215.3-228.8 243.7 26.9 26.6 43.6 63.4 43.6 104.2l0 128.8c0.9 10.3 0 20.5 17.2 20.5C878.1 942.4 1024 750.9 1024 525.3c0-282.9-229.3-512-512-512C229.1 13.2 0 242.3 0 525.2L0 525.2z" />
</svg>
</div>
        </a>
      </li></ul>
</div>
</div>
    </div><div class="site-info mt-2">
      <div>© Jingwen Zheng 2021,
        Powered by <a title="Jekyll is a simple, blog-aware, static site generator." href="http://jekyllrb.com/">Jekyll</a> & <a
        title="TeXt is a super customizable Jekyll theme." href="https://github.com/kitian616/jekyll-TeXt-theme">TeXt Theme</a>.
      </div>
    </div>
  </div>
</footer>
</div></div>
    </div><script>(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    var $body = $('body'), $window = $(window);
    var $pageRoot = $('.js-page-root'), $pageMain = $('.js-page-main');
    var activeCount = 0;
    function modal(options) {
      var $root = this, visible, onChange, hideWhenWindowScroll = false;
      var scrollTop;
      function setOptions(options) {
        var _options = options || {};
        visible = _options.initialVisible === undefined ? false : show;
        onChange = _options.onChange;
        hideWhenWindowScroll = _options.hideWhenWindowScroll;
      }
      function init() {
        setState(visible);
      }
      function setState(isShow) {
        if (isShow === visible) {
          return;
        }
        visible = isShow;
        if (visible) {
          activeCount++;
          scrollTop = $(window).scrollTop() || $pageMain.scrollTop();
          $root.addClass('modal--show');
          $pageMain.scrollTop(scrollTop);
          activeCount === 1 && ($pageRoot.addClass('show-modal'), $body.addClass('of-hidden'));
          hideWhenWindowScroll && window.hasEvent('touchstart') && $window.on('scroll', hide);
          $window.on('keyup', handleKeyup);
        } else {
          activeCount > 0 && activeCount--;
          $root.removeClass('modal--show');
          $window.scrollTop(scrollTop);
          activeCount === 0 && ($pageRoot.removeClass('show-modal'), $body.removeClass('of-hidden'));
          hideWhenWindowScroll && window.hasEvent('touchstart') && $window.off('scroll', hide);
          $window.off('keyup', handleKeyup);
        }
        onChange && onChange(visible);
      }
      function show() {
        setState(true);
      }
      function hide() {
        setState(false);
      }
      function handleKeyup(e) {
        // Char Code: 27  ESC
        if (e.which ===  27) {
          hide();
        }
      }
      setOptions(options);
      init();
      return {
        show: show,
        hide: hide,
        $el: $root
      };
    }
    $.fn.modal = modal;
  });
})();
</script><div class="modal modal--overflow page__search-modal d-print-none js-page-search-modal"><script>
(function () {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    // search panel
    var search = (window.search || (window.search = {}));
    var useDefaultSearchBox = window.useDefaultSearchBox === undefined ?
      true : window.useDefaultSearchBox ;

    var $searchModal = $('.js-page-search-modal');
    var $searchToggle = $('.js-search-toggle');
    var searchModal = $searchModal.modal({ onChange: handleModalChange, hideWhenWindowScroll: true });
    var modalVisible = false;
    search.searchModal = searchModal;

    var $searchBox = null;
    var $searchInput = null;
    var $searchClear = null;

    function getModalVisible() {
      return modalVisible;
    }
    search.getModalVisible = getModalVisible;

    function handleModalChange(visible) {
      modalVisible = visible;
      if (visible) {
        search.onShow && search.onShow();
        useDefaultSearchBox && $searchInput[0] && $searchInput[0].focus();
      } else {
        search.onShow && search.onHide();
        useDefaultSearchBox && $searchInput[0] && $searchInput[0].blur();
        setTimeout(function() {
          useDefaultSearchBox && ($searchInput.val(''), $searchBox.removeClass('not-empty'));
          search.clear && search.clear();
          window.pageAsideAffix && window.pageAsideAffix.refresh();
        }, 400);
      }
    }

    $searchToggle.on('click', function() {
      modalVisible ? searchModal.hide() : searchModal.show();
    });
    // Char Code: 83  S, 191 /
    $(window).on('keyup', function(e) {
      if (!modalVisible && !window.isFormElement(e.target || e.srcElement) && (e.which === 83 || e.which === 191)) {
        modalVisible || searchModal.show();
      }
    });

    if (useDefaultSearchBox) {
      $searchBox = $('.js-search-box');
      $searchInput = $searchBox.children('input');
      $searchClear = $searchBox.children('.js-icon-clear');
      search.getSearchInput = function() {
        return $searchInput.get(0);
      };
      search.getVal = function() {
        return $searchInput.val();
      };
      search.setVal = function(val) {
        $searchInput.val(val);
      };

      $searchInput.on('focus', function() {
        $(this).addClass('focus');
      });
      $searchInput.on('blur', function() {
        $(this).removeClass('focus');
      });
      $searchInput.on('input', window.throttle(function() {
        var val = $(this).val();
        if (val === '' || typeof val !== 'string') {
          search.clear && search.clear();
        } else {
          $searchBox.addClass('not-empty');
          search.onInputNotEmpty && search.onInputNotEmpty(val);
        }
      }, 400));
      $searchClear.on('click', function() {
        $searchInput.val(''); $searchBox.removeClass('not-empty');
        search.clear && search.clear();
      });
    }
  });
})();
</script><div class="search search--dark">
  <div class="main">
    <div class="search__header">Search</div>
    <div class="search-bar">
      <div class="search-box js-search-box">
        <div class="search-box__icon-search"><i class="fas fa-search"></i></div>
        <input type="text" />
        <div class="search-box__icon-clear js-icon-clear">
          <a><i class="fas fa-times"></i></a>
        </div>
      </div>
      <button class="button button--theme-dark button--pill search__cancel js-search-toggle">
        Cancel</button>
    </div>
    <div class="search-result js-search-result"></div>
  </div>
</div>
<script>var SOURCES = window.TEXT_VARIABLES.sources;
var PAHTS = window.TEXT_VARIABLES.paths;
window.Lazyload.js([SOURCES.jquery, PAHTS.search_js], function() {
  var search = (window.search || (window.search = {}));
  var searchData = window.TEXT_SEARCH_DATA || {};

  function memorize(f) {
    var cache = {};
    return function () {
      var key = Array.prototype.join.call(arguments, ',');
      if (key in cache) return cache[key];
      else return cache[key] = f.apply(this, arguments);
    };
  }

  /// search
  function searchByQuery(query) {
    var i, j, key, keys, cur, _title, result = {};
    keys = Object.keys(searchData);
    for (i = 0; i < keys.length; i++) {
      key = keys[i];
      for (j = 0; j < searchData[key].length; j++) {
        cur = searchData[key][j], _title = cur.title;
        if ((result[key] === undefined || result[key] && result[key].length < 4 )
          && _title.toLowerCase().indexOf(query.toLowerCase()) >= 0) {
          if (result[key] === undefined) {
            result[key] = [];
          }
          result[key].push(cur);
        }
      }
    }
    return result;
  }

  var renderHeader = memorize(function(header) {
    return $('<p class="search-result__header">' + header + '</p>');
  });

  var renderItem = function(index, title, url) {
    return $('<li class="search-result__item" data-index="' + index + '"><a class="button" href="' + url + '">' + title + '</a></li>');
  };

  function render(data) {
    if (!data) { return null; }
    var $root = $('<ul></ul>'), i, j, key, keys, cur, itemIndex = 0;
    keys = Object.keys(data);
    for (i = 0; i < keys.length; i++) {
      key = keys[i];
      $root.append(renderHeader(key));
      for (j = 0; j < data[key].length; j++) {
        cur = data[key][j];
        $root.append(renderItem(itemIndex++, cur.title, cur.url));
      }
    }
    return $root;
  }

  // search box
  var $result = $('.js-search-result'), $resultItems;
  var lastActiveIndex, activeIndex;

  function clear() {
    $result.html(null);
    $resultItems = $('.search-result__item'); activeIndex = 0;
  }
  function onInputNotEmpty(val) {
    $result.html(render(searchByQuery(val)));
    $resultItems = $('.search-result__item'); activeIndex = 0;
    $resultItems.eq(0).addClass('active');
  }

  search.clear = clear;
  search.onInputNotEmpty = onInputNotEmpty;

  function updateResultItems() {
    lastActiveIndex >= 0 && $resultItems.eq(lastActiveIndex).removeClass('active');
    activeIndex >= 0 && $resultItems.eq(activeIndex).addClass('active');
  }

  function moveActiveIndex(direction) {
    var itemsCount = $resultItems ? $resultItems.length : 0;
    if (itemsCount > 1) {
      lastActiveIndex = activeIndex;
      if (direction === 'up') {
        activeIndex = (activeIndex - 1 + itemsCount) % itemsCount;
      } else if (direction === 'down') {
        activeIndex = (activeIndex + 1 + itemsCount) % itemsCount;
      }
      updateResultItems();
    }
  }

  // Char Code: 13  Enter, 37  ⬅, 38  ⬆, 39  ➡, 40  ⬇
  $(window).on('keyup', function(e) {
    var modalVisible = search.getModalVisible && search.getModalVisible();
    if (modalVisible) {
      if (e.which === 38) {
        modalVisible && moveActiveIndex('up');
      } else if (e.which === 40) {
        modalVisible && moveActiveIndex('down');
      } else if (e.which === 13) {
        modalVisible && $resultItems && activeIndex >= 0 && $resultItems.eq(activeIndex).children('a')[0].click();
      }
    }
  });

  $result.on('mouseover', '.search-result__item > a', function() {
    var itemIndex = $(this).parent().data('index');
    itemIndex >= 0 && (lastActiveIndex = activeIndex, activeIndex = itemIndex, updateResultItems());
  });
});
</script>
</div></div>


<script>(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    function scrollToAnchor(anchor, duration, callback) {
      var $root = this;
      $root.animate({ scrollTop: $(anchor).position().top }, duration, function() {
        window.history.replaceState(null, '', window.location.href.split('#')[0] + anchor);
        callback && callback();
      });
    }
    $.fn.scrollToAnchor = scrollToAnchor;
  });
})();
(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    function affix(options) {
      var $root = this, $window = $(window), $scrollTarget, $scroll,
        offsetBottom = 0, scrollTarget = window, scroll = window.document, disabled = false, isOverallScroller = true,
        rootTop, rootLeft, rootHeight, scrollBottom, rootBottomTop,
        hasInit = false, curState;

      function setOptions(options) {
        var _options = options || {};
        _options.offsetBottom && (offsetBottom = _options.offsetBottom);
        _options.scrollTarget && (scrollTarget = _options.scrollTarget);
        _options.scroll && (scroll = _options.scroll);
        _options.disabled !== undefined && (disabled = _options.disabled);
        $scrollTarget = $(scrollTarget);
        isOverallScroller = window.isOverallScroller($scrollTarget[0]);
        $scroll = $(scroll);
      }
      function preCalc() {
        top();
        rootHeight = $root.outerHeight();
        rootTop = $root.offset().top + (isOverallScroller ? 0 :  $scrollTarget.scrollTop());
        rootLeft = $root.offset().left;
      }
      function calc(needPreCalc) {
        needPreCalc && preCalc();
        scrollBottom = $scroll.outerHeight() - offsetBottom - rootHeight;
        rootBottomTop = scrollBottom - rootTop;
      }
      function top() {
        if (curState !== 'top') {
          $root.removeClass('fixed').css({
            left: 0,
            top: 0
          });
          curState = 'top';
        }
      }
      function fixed() {
        if (curState !== 'fixed') {
          $root.addClass('fixed').css({
            left: rootLeft + 'px',
            top: 0
          });
          curState = 'fixed';
        }
      }
      function bottom() {
        if (curState !== 'bottom') {
          $root.removeClass('fixed').css({
            left: 0,
            top: rootBottomTop + 'px'
          });
          curState = 'bottom';
        }
      }
      function setState() {
        var scrollTop = $scrollTarget.scrollTop();
        if (scrollTop >= rootTop && scrollTop <= scrollBottom) {
          fixed();
        } else if (scrollTop < rootTop) {
          top();
        } else {
          bottom();
        }
      }
      function init() {
        if(!hasInit) {
          var interval, timeout;
          calc(true); setState();
          // run calc every 100 millisecond
          interval = setInterval(function() {
            calc();
          }, 100);
          timeout = setTimeout(function() {
            clearInterval(interval);
          }, 45000);
          window.pageLoad.then(function() {
            setTimeout(function() {
              clearInterval(interval);
              clearTimeout(timeout);
            }, 3000);
          });
          $scrollTarget.on('scroll', function() {
            disabled || setState();
          });
          $window.on('resize', function() {
            disabled || (calc(true), setState());
          });
          hasInit = true;
        }
      }

      setOptions(options);
      if (!disabled) {
        init();
      }
      $window.on('resize', window.throttle(function() {
        init();
      }, 200));
      return {
        setOptions: setOptions,
        refresh: function() {
          calc(true, { animation: false }); setState();
        }
      };
    }
    $.fn.affix = affix;
  });
})();
(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    function toc(options) {
      var $root = this, $window = $(window), $scrollTarget, $scroller, $tocUl = $('<ul class="toc toc--ellipsis"></ul>'), $tocLi, $headings, $activeLast, $activeCur,
        selectors = 'h1,h2,h3', container = 'body', scrollTarget = window, scroller = 'html, body', disabled = false,
        headingsPos, scrolling = false, hasRendered = false, hasInit = false;

      function setOptions(options) {
        var _options = options || {};
        _options.selectors && (selectors = _options.selectors);
        _options.container && (container = _options.container);
        _options.scrollTarget && (scrollTarget = _options.scrollTarget);
        _options.scroller && (scroller = _options.scroller);
        _options.disabled !== undefined && (disabled = _options.disabled);
        $headings = $(container).find(selectors).filter('[id]');
        $scrollTarget = $(scrollTarget);
        $scroller = $(scroller);
      }
      function calc() {
        headingsPos = [];
        $headings.each(function() {
          headingsPos.push(Math.floor($(this).position().top));
        });
      }
      function setState(element, disabled) {
        var scrollTop = $scrollTarget.scrollTop(), i;
        if (disabled || !headingsPos || headingsPos.length < 1) { return; }
        if (element) {
          $activeCur = element;
        } else {
          for (i = 0; i < headingsPos.length; i++) {
            if (scrollTop >= headingsPos[i]) {
              $activeCur = $tocLi.eq(i);
            } else {
              $activeCur || ($activeCur = $tocLi.eq(i));
              break;
            }
          }
        }
        $activeLast && $activeLast.removeClass('active');
        ($activeLast = $activeCur).addClass('active');
      }
      function render() {
        if(!hasRendered) {
          $root.append($tocUl);
          $headings.each(function() {
            var $this = $(this);
            $tocUl.append($('<li></li>').addClass('toc-' + $this.prop('tagName').toLowerCase())
              .append($('<a></a>').text($this.text()).attr('href', '#' + $this.prop('id'))));
          });
          $tocLi = $tocUl.children('li');
          $tocUl.on('click', 'a', function(e) {
            e.preventDefault();
            var $this = $(this);
            scrolling = true;
            setState($this.parent());
            $scroller.scrollToAnchor($this.attr('href'), 400, function() {
              scrolling = false;
            });
          });
        }
        hasRendered = true;
      }
      function init() {
        var interval, timeout;
        if(!hasInit) {
          render(); calc(); setState(null, scrolling);
          // run calc every 100 millisecond
          interval = setInterval(function() {
            calc();
          }, 100);
          timeout = setTimeout(function() {
            clearInterval(interval);
          }, 45000);
          window.pageLoad.then(function() {
            setTimeout(function() {
              clearInterval(interval);
              clearTimeout(timeout);
            }, 3000);
          });
          $scrollTarget.on('scroll', function() {
            disabled || setState(null, scrolling);
          });
          $window.on('resize', window.throttle(function() {
            if (!disabled) {
              render(); calc(); setState(null, scrolling);
            }
          }, 100));
        }
        hasInit = true;
      }

      setOptions(options);
      if (!disabled) {
        init();
      }
      $window.on('resize', window.throttle(function() {
        init();
      }, 200));
      return {
        setOptions: setOptions
      };
    }
    $.fn.toc = toc;
  });
})();
/*(function () {

})();*/
</script><script>
  /* toc must before affix, since affix need to konw toc' height. */(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  var TOC_SELECTOR = window.TEXT_VARIABLES.site.toc.selectors;
  window.Lazyload.js(SOURCES.jquery, function() {
    var $window = $(window);
    var $articleContent = $('.js-article-content');
    var $tocRoot = $('.js-toc-root'), $col2 = $('.js-col-aside');
    var toc;
    var tocDisabled = false;
    var hasSidebar = $('.js-page-root').hasClass('layout--page--sidebar');
    var hasToc = $articleContent.find(TOC_SELECTOR).length > 0;

    function disabled() {
      return $col2.css('display') === 'none' || !hasToc;
    }

    tocDisabled = disabled();

    toc = $tocRoot.toc({
      selectors: TOC_SELECTOR,
      container: $articleContent,
      scrollTarget: hasSidebar ? '.js-page-main' : null,
      scroller: hasSidebar ? '.js-page-main' : null,
      disabled: tocDisabled
    });

    $window.on('resize', window.throttle(function() {
      tocDisabled = disabled();
      toc && toc.setOptions({
        disabled: tocDisabled
      });
    }, 100));

  });
})();
(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    var $window = $(window), $pageFooter = $('.js-page-footer');
    var $pageAside = $('.js-page-aside');
    var affix;
    var tocDisabled = false;
    var hasSidebar = $('.js-page-root').hasClass('layout--page--sidebar');

    affix = $pageAside.affix({
      offsetBottom: $pageFooter.outerHeight(),
      scrollTarget: hasSidebar ? '.js-page-main' : null,
      scroller: hasSidebar ? '.js-page-main' : null,
      scroll: hasSidebar ? $('.js-page-main').children() : null,
      disabled: tocDisabled
    });

    $window.on('resize', window.throttle(function() {
      affix && affix.setOptions({
        disabled: tocDisabled
      });
    }, 100));

    window.pageAsideAffix = affix;
  });
})();
</script>
    </div>
    <script>(function () {
  var $root = document.getElementsByClassName('root')[0];
  if (window.hasEvent('touchstart')) {
    $root.dataset.isTouch = true;
    document.addEventListener('touchstart', function(){}, false);
  }
})();
</script>
  </body>
</html>

